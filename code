import matplotlib.pyplot as plt# for visulaiztion
import matplotlib.patches as patches
import numpy as np
from queue import Queue, LifoQueue, PriorityQueue


GRID_ROWS = 5
GRID_COLS = 5
START = (0, 0)
TARGET = (0, 1)
STATIC_WALLS = [(1,2), (2,2), (3,3)]
VISUAL_DELAY = 0.05

MOVES = [(-1,0),  # Up
         (0,1),   # Right
         (1,0),   # Down
         (1,1),   # Bottom-Right (Main Diagonal)
         (0,-1),  # Left
         (-1,-1)] # Top-Left (Main Diagonal)

#printing the keys
print("Color Legend:")
print("Green  -> Start")
print("Blue   -> Target")
print("Black  -> Static Walls")
print("Cyan   -> Explored Nodes")
print("Orange -> Frontier Nodes")
print("Yellow -> Final Path\n")

# Visualization Function

def draw_grid(grid, frontier=[], explored=[], path=[], algorithm=""):
    plt.figure(figsize=(3,3))
    ax = plt.gca()
    ax.set_title(f"Algorithm: {algorithm}", fontsize=12, pad=15)
    
    ax.set_xticks(np.arange(GRID_COLS))
    ax.set_yticks(np.arange(GRID_ROWS))
    
    ax.xaxis.set_ticks_position('top') 
    plt.grid(True)
    
    # Draw all cells
    for r in range(GRID_ROWS):
        for c in range(GRID_COLS):
            if (r,c) in STATIC_WALLS:
                ax.add_patch(patches.Rectangle((c, r), 1, 1, color='black'))
    
    for (r, c) in explored:
        ax.add_patch(patches.Rectangle((c, r), 1, 1, color='cyan', alpha=0.5))
    
    for (r, c) in frontier:
        ax.add_patch(patches.Rectangle((c, r), 1, 1, color='orange', alpha=0.7))
    
    for (r, c) in path:
        ax.add_patch(patches.Rectangle((c, r), 1, 1, color='yellow', alpha=0.7))
    
    ax.add_patch(patches.Rectangle((START[1], START[0]), 1, 1, color='green'))
    ax.add_patch(patches.Rectangle((TARGET[1], TARGET[0]), 1, 1, color='blue'))
    
    ax.set_xlim(0, GRID_COLS)
    ax.set_ylim(0, GRID_ROWS)
    ax.set_aspect('equal')
    ax.invert_yaxis()  # row 0 on top
    
    plt.pause(VISUAL_DELAY)
    plt.clf()


# Utility Functions

def is_valid(pos, grid):
    r, c = pos
    return 0 <= r < GRID_ROWS and 0 <= c < GRID_COLS and grid[r][c] == 0

def reconstruct_path(parent, end):
    path = []
    node = end
    while node in parent:
        path.append(node)
        node = parent[node]
    path.append(START)
    path.reverse()
    return path


# 1. BFS

def BFS(grid):
    visited = set()
    parent = {}
    queue = Queue()
    queue.put(START)
    visited.add(START)
    
    while not queue.empty():
        node = queue.get()
        frontier = list(queue.queue)
        draw_grid(grid, frontier=frontier, explored=visited, algorithm="BFS")
        
        if node == TARGET:
            return reconstruct_path(parent, node)
        
        for move in MOVES:
            neighbor = (node[0]+move[0], node[1]+move[1])
            if is_valid(neighbor, grid) and neighbor not in visited:
                queue.put(neighbor)
                visited.add(neighbor)
                parent[neighbor] = node
    return None


# 2. DFS

def DFS(grid):
    visited = set()
    parent = {}
    stack = LifoQueue()
    stack.put(START)
    visited.add(START)
    
    while not stack.empty():
        node = stack.get()
        frontier = list(stack.queue)
        draw_grid(grid, frontier=frontier, explored=visited, algorithm="DFS")
        
        if node == TARGET:
            return reconstruct_path(parent, node)
        
        for move in MOVES:
            neighbor = (node[0]+move[0], node[1]+move[1])
            if is_valid(neighbor, grid) and neighbor not in visited:
                stack.put(neighbor)
                visited.add(neighbor)
                parent[neighbor] = node
    return None

# 3. UCS

def UCS(grid):
    visited = set()
    parent = {}
    pq = PriorityQueue()
    pq.put((0, START))
    cost = {START: 0}
    
    while not pq.empty():
        c, node = pq.get()
        frontier = [item[1] for item in pq.queue]
        draw_grid(grid, frontier=frontier, explored=visited, algorithm="UCS")
        visited.add(node)
        
        if node == TARGET:
            return reconstruct_path(parent, node)
        
        for move in MOVES:
            neighbor = (node[0]+move[0], node[1]+move[1])
            if is_valid(neighbor, grid):
                new_cost = c + 1
                if neighbor not in cost or new_cost < cost[neighbor]:
                    cost[neighbor] = new_cost
                    pq.put((new_cost, neighbor))
                    parent[neighbor] = node
    return None


# 4. DLS
def DLS(grid, limit=10):
    visited = set()
    parent = {}
    
    def recursive(node, depth):
        if depth > limit:
            return None
        visited.add(node)
        draw_grid(grid, frontier=[], explored=visited, algorithm=f"DLS (limit={limit})")
        if node == TARGET:
            return node
        for move in MOVES:
            neighbor = (node[0]+move[0], node[1]+move[1])
            if is_valid(neighbor, grid) and neighbor not in visited:
                parent[neighbor] = node
                result = recursive(neighbor, depth+1)
                if result:
                    return result
        return None
    
    result = recursive(START, 0)
    if result:
        return reconstruct_path(parent, TARGET)
    return None

# 5. IDDFS
def IDDFS(grid, max_depth=10):
    for depth in range(max_depth):
        visited = set()
        parent = {}
        
        def recursive(node, d):
            if d > depth:
                return None
            visited.add(node)
            draw_grid(grid, frontier=[], explored=visited, algorithm=f"IDDFS depth={depth}")
            if node == TARGET:
                return node
            for move in MOVES:
                neighbor = (node[0]+move[0], node[1]+move[1])
                if is_valid(neighbor, grid) and neighbor not in visited:
                    parent[neighbor] = node
                    result = recursive(neighbor, d+1)
                    if result:
                        return result
            return None
        
        result = recursive(START, 0)
        if result:
            return reconstruct_path(parent, TARGET)
    return None

# 6. Bidirectional Search
def BidirectionalSearch(grid):
    start_visited = {START: None}
    target_visited = {TARGET: None}
    
    start_queue = Queue()
    target_queue = Queue()
    start_queue.put(START)
    target_queue.put(TARGET)
    
    meeting_point = None
    
    while not start_queue.empty() and not target_queue.empty():
        # Expand from start
        node_s = start_queue.get()
        draw_grid(grid, frontier=list(start_queue.queue), explored=start_visited.keys(), algorithm="Bidirectional Search")
        for move in MOVES:
            neighbor = (node_s[0]+move[0], node_s[1]+move[1])
            if is_valid(neighbor, grid) and neighbor not in start_visited:
                start_visited[neighbor] = node_s
                start_queue.put(neighbor)
                if neighbor in target_visited:
                    meeting_point = neighbor
                    break
        if meeting_point:
            break
        
        # Expand from target
        node_t = target_queue.get()
        draw_grid(grid, frontier=list(target_queue.queue), explored=target_visited.keys(), algorithm="Bidirectional Search")
        for move in MOVES:
            neighbor = (node_t[0]+move[0], node_t[1]+move[1])
            if is_valid(neighbor, grid) and neighbor not in target_visited:
                target_visited[neighbor] = node_t
                target_queue.put(neighbor)
                if neighbor in start_visited:
                    meeting_point = neighbor
                    break
        if meeting_point:
            break
    
    if not meeting_point:
        return None
    
    # Reconstruct path
    path_s = []
    node = meeting_point
    while node:
        path_s.append(node)
        node = start_visited[node]
    path_s.reverse()
    
    path_t = []
    node = target_visited[meeting_point]
    while node:
        path_t.append(node)
        node = target_visited[node]
    
    return path_s + path_t

# Main Execution
grid = np.zeros((GRID_ROWS, GRID_COLS))
for wall in STATIC_WALLS:
    grid[wall[0]][wall[1]] = 1

plt.ion()
plt.show()

algorithms = [
    ("BFS", lambda: BFS(grid.copy())),
    ("DFS", lambda: DFS(grid.copy())),
    ("UCS", lambda: UCS(grid.copy())),
    ("DLS", lambda: DLS(grid.copy(), limit=10)),
    ("IDDFS", lambda: IDDFS(grid.copy(), max_depth=10)),
    ("Bidirectional Search", lambda: BidirectionalSearch(grid.copy()))
]

for name, algo in algorithms:
    print(f"Running {name}...")

    
    path = algo()
    
    if path:
        draw_grid(grid, path=path, algorithm=f"{name} Final Path")
        print(f"{name} Path found! Total Steps: {len(path)}")
        for i, pos in enumerate(path):
            print(f"Step {i+1}: {pos}")
    else:
        print(f"{name}: No path found.")

plt.ioff()
plt.show()

